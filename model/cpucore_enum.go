// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package model

import (
	"errors"
	"fmt"
)

const (
	CBTargetB CBTarget = iota
	CBTargetC
	CBTargetD
	CBTargetE
	CBTargetH
	CBTargetL
	CBTargetIndirectHL
	CBTargetA
)

var ErrInvalidCBTarget = errors.New("not a valid CBTarget")

const _CBTargetName = "BCDEHLIndirectHLA"

// CBTargetValues returns a list of the values for CBTarget
func CBTargetValues() []CBTarget {
	return []CBTarget{
		CBTargetB,
		CBTargetC,
		CBTargetD,
		CBTargetE,
		CBTargetH,
		CBTargetL,
		CBTargetIndirectHL,
		CBTargetA,
	}
}

var _CBTargetMap = map[CBTarget]string{
	CBTargetB:          _CBTargetName[0:1],
	CBTargetC:          _CBTargetName[1:2],
	CBTargetD:          _CBTargetName[2:3],
	CBTargetE:          _CBTargetName[3:4],
	CBTargetH:          _CBTargetName[4:5],
	CBTargetL:          _CBTargetName[5:6],
	CBTargetIndirectHL: _CBTargetName[6:16],
	CBTargetA:          _CBTargetName[16:17],
}

// String implements the Stringer interface.
func (x CBTarget) String() string {
	if str, ok := _CBTargetMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CBTarget(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x CBTarget) IsValid() bool {
	_, ok := _CBTargetMap[x]
	return ok
}

var _CBTargetValue = map[string]CBTarget{
	_CBTargetName[0:1]:   CBTargetB,
	_CBTargetName[1:2]:   CBTargetC,
	_CBTargetName[2:3]:   CBTargetD,
	_CBTargetName[3:4]:   CBTargetE,
	_CBTargetName[4:5]:   CBTargetH,
	_CBTargetName[5:6]:   CBTargetL,
	_CBTargetName[6:16]:  CBTargetIndirectHL,
	_CBTargetName[16:17]: CBTargetA,
}

// ParseCBTarget attempts to convert a string to a CBTarget.
func ParseCBTarget(name string) (CBTarget, error) {
	if x, ok := _CBTargetValue[name]; ok {
		return x, nil
	}
	return CBTarget(0), fmt.Errorf("%s is %w", name, ErrInvalidCBTarget)
}

// MarshalText implements the text marshaller method.
func (x CBTarget) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *CBTarget) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCBTarget(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// Set implements the Golang flag.Value interface func.
func (x *CBTarget) Set(val string) error {
	v, err := ParseCBTarget(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *CBTarget) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *CBTarget) Type() string {
	return "CBTarget"
}

const (
	OpcodeNop   Opcode = iota
	OpcodeLDCn  Opcode = iota + 13
	OpcodeJRNZe Opcode = iota + 30
	OpcodeLDHLnn
	OpcodeLDSPnn Opcode = iota + 45
	OpcodeLDHLADec
	OpcodeLDAn Opcode = iota + 56
	OpcodeXORA Opcode = iota + 168
	OpcodeCB   Opcode = iota + 195
	OpcodeDI   Opcode = iota + 234
	OpcodeEI   Opcode = iota + 241
)

var ErrInvalidOpcode = errors.New("not a valid Opcode")

const _OpcodeName = "NopLDCnJRNZeLDHLnnLDSPnnLDHLADecLDAnXORACBDIEI"

// OpcodeValues returns a list of the values for Opcode
func OpcodeValues() []Opcode {
	return []Opcode{
		OpcodeNop,
		OpcodeLDCn,
		OpcodeJRNZe,
		OpcodeLDHLnn,
		OpcodeLDSPnn,
		OpcodeLDHLADec,
		OpcodeLDAn,
		OpcodeXORA,
		OpcodeCB,
		OpcodeDI,
		OpcodeEI,
	}
}

var _OpcodeMap = map[Opcode]string{
	OpcodeNop:      _OpcodeName[0:3],
	OpcodeLDCn:     _OpcodeName[3:7],
	OpcodeJRNZe:    _OpcodeName[7:12],
	OpcodeLDHLnn:   _OpcodeName[12:18],
	OpcodeLDSPnn:   _OpcodeName[18:24],
	OpcodeLDHLADec: _OpcodeName[24:32],
	OpcodeLDAn:     _OpcodeName[32:36],
	OpcodeXORA:     _OpcodeName[36:40],
	OpcodeCB:       _OpcodeName[40:42],
	OpcodeDI:       _OpcodeName[42:44],
	OpcodeEI:       _OpcodeName[44:46],
}

// String implements the Stringer interface.
func (x Opcode) String() string {
	if str, ok := _OpcodeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Opcode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Opcode) IsValid() bool {
	_, ok := _OpcodeMap[x]
	return ok
}

var _OpcodeValue = map[string]Opcode{
	_OpcodeName[0:3]:   OpcodeNop,
	_OpcodeName[3:7]:   OpcodeLDCn,
	_OpcodeName[7:12]:  OpcodeJRNZe,
	_OpcodeName[12:18]: OpcodeLDHLnn,
	_OpcodeName[18:24]: OpcodeLDSPnn,
	_OpcodeName[24:32]: OpcodeLDHLADec,
	_OpcodeName[32:36]: OpcodeLDAn,
	_OpcodeName[36:40]: OpcodeXORA,
	_OpcodeName[40:42]: OpcodeCB,
	_OpcodeName[42:44]: OpcodeDI,
	_OpcodeName[44:46]: OpcodeEI,
}

// ParseOpcode attempts to convert a string to a Opcode.
func ParseOpcode(name string) (Opcode, error) {
	if x, ok := _OpcodeValue[name]; ok {
		return x, nil
	}
	return Opcode(0), fmt.Errorf("%s is %w", name, ErrInvalidOpcode)
}

// MarshalText implements the text marshaller method.
func (x Opcode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Opcode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseOpcode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// Set implements the Golang flag.Value interface func.
func (x *Opcode) Set(val string) error {
	v, err := ParseOpcode(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *Opcode) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *Opcode) Type() string {
	return "Opcode"
}
